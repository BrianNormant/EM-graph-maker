import plotly
import yaml/serialization, streams
import sugar
import std/math
import os
import std/enumerate

const PLANES_DIR = "./planes"

### Physics
type
  Plane = object
    name: string    # Name of the plane.
    S: float64      # Wing area of the plan. m²
    W: float64      # Weight of the aircraft, Gross takeoff Weight + fuel kg
    CL_max: float64 # Maximun Lift coefficient
    M: float        # speed at which the compression of control surfaces become significant

const
  nmax = 9.0         # Maximum G load factor considered, G
  Vmax = 600.0 / 3.6 # Maximum Speed considered m/s
  ρ = 1.204         # Air density kg/m^3
  g = 9.80665        # Gravity m/s^2

## Calculate the maximun turnrate at a given speed with a given G_load
func g_load_max(speed: float, G_load: float): float =
  G_load * g / speed

## Simulate how the CL_max varies depending on the speed
func compression_factor(v: float, M: float): float =
  if v <= 0:
    1.0
  elif v <= M:
    1 - v/M
  else:
    0.25

    #[
                    Sources:
              - https://aviation.stackexchange.com/questions/96827/computing-an-energy-maneuverability-e-m-diagram-for-an-aircraft
              - https://www.researchgate.net/publication/269058442_A_framework_for_analysis_of_aircraft_maneuverability_AIAA-95-3448
                    The lift of an aircraft is the force generated by the airflow on the wings.
                    Lift = CL_max * Q * S
              where Q is the dynamic pressure, ie the force that can be generated by a given surface.
                    Q = ½ * ρ * v²
              For any given speed, the plane have to first overcome the G with its lift. Thus the speed must be greater than takeoff speed. If the speed is lower, then its assumed that the instaneous turn rate is equal to -1
                    TakeOffSpeed is given by : √( m / ½ * ρ * cl_max * S )
                    coincidentaly the takeoff speed is the stall speed.
              When the aircraft is flying faster than takeoff speed, the available lift can be used to turn.
              However, the aircraft strutural limit can not be overcome. How many degree can be turned at any speed is constant between every aircraft and is given by :
                    ]#
func calculate_turn(plane: Plane, v: float): float =
  let cl = plane.CL_max
  let x = ( (ρ * v^2 * plane.S * cl) / (2 * plane.W * g)) ^ 2 - 1
  if x < 0:
    return 0
  else:
    return min(
      g * sqrt(x) / v,
      g_load_max(v, nmax)
    )

#------------ Simulation
let nb_data_point = 500 # How many data point to show on the graph.



when isMainModule:

  var speeds = collect:
    for i in 1..nb_data_point:
      i.float * Vmax.float/nb_data_point.float

  var planes: seq[Plane]
  var turns = newSeq[seq[float]]()

  # First load the all the planes to simulate.
  if dirExists(PLANES_DIR):
    let files = collect(newSeq):
      for file in walkDir(PLANES_DIR): file

    if files.len == 0:
      echo "No planes found in ", PLANES_DIR

    for file in files:
      var tmp: seq[Plane]

      var s = newFileStream(file[1])
      load(s, tmp)
      s.close()
      echo "Loaded ", tmp[^1].name, " from file ", file[1]
      planes.add tmp[^1]

  else:
    echo "Planes directory not found."
  echo "Nb plane ", planes.len
  # Then simulate the maximun turn rate for any given airspeed for each airplane.

  for plane in planes:
    var tmp = newSeq[float]()
    for i in 0..<nb_data_point:
      tmp.add calculate_turn(plane, speeds[i]).radtodeg
    turns.add(tmp)

  for i, v in enumerate(speeds): speeds[i] = v * 3.6

  # Finally, render the graph
  var dd: seq[Trace[float]] = collect:
    for i in 0..<planes.len:
      (var d = Trace[float](mode: PlotMode.Lines,
          `type`: PlotType.Scatter, name: planes[i].name);
      d.xs = speeds;
      d.ys = turns[i];
      d)

  var layout = Layout(
    title: "Energy Maneuvering Diagram at sea level",
    width: 1200,
    height: 800,
    xaxis: Axis(title: "Speed TAS [km/h]"),
    yaxis: Axis(title: "Turn rate [deg/s]"),
    autosize: true
  )
  var p = Plot[float](layout: layout, traces: dd)
  p.show()
